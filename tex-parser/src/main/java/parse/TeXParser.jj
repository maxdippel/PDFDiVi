options{  STATIC = false;  DEBUG_PARSER = false;  DEBUG_LOOKAHEAD = false;  DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(TeXParser)package parse;import model.Element;import model.Command;import model.MacroDefinition;import model.NewParagraph;import model.NewLine;import model.Group;import model.Text;import model.Marker;import model.Option;import model.Document;import model.Whitespace;import java.util.Arrays;import java.util.Stack;import java.util.Map;import java.util.Set;import java.util.HashSet;import java.util.HashMap;import java.util.LinkedList;import java.lang.Integer;/** * Class to parse any tex document. */public class TeXParser {  /**   * Flag to toggle between debug modes.   */  protected final boolean DEBUG = false;  /**   * The parsed macro definitions.   */  protected Map <String, Group> macros = new HashMap <String, Group>();  /**   * The list of all scheduled characters on checking if a command name belongs   * to a macro defined command.    */  protected LinkedList <Character> schedule = new LinkedList <Character> ();  /**   * The lookahead string on checking if a command name belongs to a macro   * defined command.    */  protected StringBuilder lookahead = new StringBuilder();  // ___________________________________________________________________________  protected boolean belongsToMacroDefinedCommandName() {    log("Token: " + getToken(1));        if (!schedule.isEmpty()) {      log("  Schedule is not empty: " + schedule);      // There are scheduled characters. Check, if the current token satisfy the      // schedule.      if (satisfySchedule(getToken(1))) {        log("  Token satisfies the schedule. Return true.");        return true;      } else {        resetLookahead();      }    }    int i = 1;    boolean onlyLettersOrDigits = true;    while (true) {      Token token = getToken(i);      if (isValidToken(token)) {        char [] tokenChars = toCharArray(token);        for (int j = 0; j < tokenChars.length; j++) {          char tokenChar = tokenChars[j];                    // Append the token char to the current lookahead.          lookahead.append(tokenChar);          log("  Lookahead query: " + lookahead);          // Don't consider the first token char (which must be the identifier).          if (lookahead.length() > 1) {            boolean isLetterOrDigit = Character.isLetterOrDigit(tokenChar);            onlyLettersOrDigits = onlyLettersOrDigits && isLetterOrDigit;          }                    // Check if there are macro definitions, that starts with the current          // lookahead string.          int numPrefixes = getNumberOfMacrosWithPrefix(lookahead.toString());          // Continue, if there is at least one such macro definition.          log("  numPrefixes: " + numPrefixes);          if (numPrefixes > 0) {            continue;          }                    // Check if there are macro definitions, that are equal to the current          // lookahead string.          int numMatches = getNumberOfMacrosMatches(lookahead.toString());          log("  numMatches: " + numMatches);          if (numMatches > 0) {            // Check, if the next token is a character or digit.            char nextTokenChar = getNextTokenChar(i, j);            boolean isLetterOrDigit = Character.isLetterOrDigit(nextTokenChar);            if (onlyLettersOrDigits && isLetterOrDigit) {              resetLookahead();              return false;            }            schedule.clear();                        // Create a new schedule: Schedule all following token (except the            // current one).            for (int k = getToken(1).image.length(); k < lookahead.length(); k++) {              schedule.add(lookahead.charAt(k));            }            log("  new schedule: " + schedule);            return true;          }          resetLookahead();          return false;        }      } else {        resetLookahead();        return false;      }      i++;    }  }  /**   * Prints the given message to System.out if and only if DEBUG == true.    */  protected void log(String log) {    if (DEBUG) System.out.println(log);  }  /**   * Registers the given macro definition.   */  protected void registerMacroDefinition(MacroDefinition macro) {    if (macro != null && !macro.getValues().isEmpty()) {      macros.put(macro.getKey().getText(), macro.getValues().get(0));    }  }  /**   * Transforms the given token to char array.   */  protected char [] toCharArray(Token token) {    return token.image.toCharArray();  }  /**   * Returns true, if the given token corresponds to the current schedule.   */  protected boolean satisfySchedule(Token token) {    char [] tokenChars = toCharArray(token);    boolean satisfy = true;    for (char tokenChar : tokenChars) {      if (tokenChar != schedule.pop()) {        satisfy = false;        break;      }    }    return satisfy;  }  /**   * Returns true, if the given token is valid (the token is not null and the   * image of the token is not empty).   */  protected boolean isValidToken(Token token) {    return token != null && token.image != null && !token.image.equals("");  }  /**   * Returns the next character.   */  protected char getNextTokenChar(int currentTokenIndex, int currentCharIndex) {    // Check, if there are still unvisited characters in the current token.    Token currentToken = getToken(currentTokenIndex);    if (isValidToken(currentToken)) {      char [] tokenChars = toCharArray(currentToken);      if (currentCharIndex < tokenChars.length - 1) {        return tokenChars[currentCharIndex + 1];      }    }    // Check, if there is a next token.    Token nextToken = getToken(currentTokenIndex + 1);    if (isValidToken(nextToken)) {      char [] tokenChars = toCharArray(nextToken);      if (tokenChars.length > 0) {        return tokenChars[0];      }    }    return 0;  }  /**   * Resets the current lookahead.   */  protected void resetLookahead() {    lookahead.setLength(0);    schedule.clear();  }  /**   * Computes the number of macros that start with the given prefix.   */  protected int getNumberOfMacrosWithPrefix(String prefix) {    int num = 0;    for (String macro : macros.keySet()) {      if (macro.startsWith(prefix) && !macro.equals(prefix)) {        num++;      }    }    return num;  }  /**   * Computes the number of macros that are equal to the given string   */  protected int getNumberOfMacrosMatches(String prefix) {    int num = 0;    for (String macro : macros.keySet()) {      if (macro.equals(prefix)) {        num++;      }    }    return num;  }}PARSER_END(TeXParser)// =============================================================================/** * The entry point to this parser. */public Document parse() :{  Document document = new Document();}{  Document(document) < EOF >  {    return document;  }}/** * Tries to identify a document in the given context. */protected void Document(Group context) :{  Token token;}{  (    Element(context)  |    (      (        token = < GROUP_END >      | token = < OPTION_END >      )      {        context.addElement(new Text(token.image, token));      }    )  )*}/** * Tries to identify a common element. That could be (a) a comment, (b) a group, * (c) an option, (d) a command, (e) a text, (f) a marker, (g) a new paragraph * or (h) a new line. */protected void Element(Group context) :{  Element element;}{  (    LOOKAHEAD(FormulaSubScript())    element = FormulaSubScript()    |    LOOKAHEAD(FormulaSuperScript())    element = FormulaSuperScript()    |    LOOKAHEAD(Command())    element = Command()    |     LOOKAHEAD(PotentialGroup())    element = PotentialGroup()    |     LOOKAHEAD(PotentialOption())    element = PotentialOption()    |     LOOKAHEAD(Text())    element = Text()    |    LOOKAHEAD(NewParagraph())    element = NewParagraph()    |     LOOKAHEAD(Newline())    element = Newline()    |     LOOKAHEAD(Whitespace())    element = Whitespace()    |     element = Marker()  )  {    context.addElement(element);  }}// _____________________________________________________________________________// Parse formula's sub- and superscripts./** * Tries to identify a command. */protected Command FormulaSubScript() :{  Command command;  Token token;  Group group;  Command subScriptCommand;}{  token = < UNDERSCORE >  {    command = new Command(token.image, token);  }  (<WHITESPACE> | < NEW_LINE >)*  (    group = Group()    {      command.addArgument(group);    }    |    // TextSymbol() returns Token, so we have to create a text element.    token = TextSymbol()    {      command.addArgument(new Text(token.image, token));    }    |    subScriptCommand = Command()    {      command.addArgument(subScriptCommand);    }   )  {    return command;  }}/** * Tries to identify a command. */protected Command FormulaSuperScript() :{  Command command;  Token token;  Group group;  Command superScriptCommand;}{  token = < CIRCUMFLEX >  {    command = new Command(token.image, token);  }  (<WHITESPACE> | < NEW_LINE >)*  (    group = Group()    {      command.addArgument(group);    }    |    // TextSymbol() returns Token, so we have to create a text element.    token = TextSymbol()    {      command.addArgument(new Text(token.image, token));    }    |    superScriptCommand = Command()    {      command.addArgument(superScriptCommand);    }   )  {    return command;  }}// _____________________________________________________________________________// Parse Commands./** * Tries to identify a command. */protected Command Command() :{  Command command = null;}{  (    LOOKAHEAD(MacroDefinition())    command = MacroDefinition()    {      registerMacroDefinition((MacroDefinition) command);    }  |    LOOKAHEAD(MacroDefinedCommand())    command = MacroDefinedCommand()  |     LOOKAHEAD(TeXCommandWithCharArgAndOptionalWhitespace())    command = TeXCommandWithCharArgAndOptionalWhitespace()  |    LOOKAHEAD(TeXCommandWithCharArgAndMandatoryWhitespace())    command = TeXCommandWithCharArgAndMandatoryWhitespace()  |    LOOKAHEAD(TeXCommandWithSingleWordArgAndOptionalWhitespace())    command = TeXCommandWithSingleWordArgAndOptionalWhitespace()  |      LOOKAHEAD(TeXCommandWithSingleWordArgAndMandatoryWhitespace())    command = TeXCommandWithSingleWordArgAndMandatoryWhitespace()  |//    LOOKAHEAD(TeXCommandWithMultipleWordsArgAndOptionalWhitespace())//    command = TeXCommandWithMultipleWordsArgAndOptionalWhitespace()//  |     LOOKAHEAD(UsualCommand())    command = UsualCommand()  |     LOOKAHEAD(WellDefinedCommand())    command = WellDefinedCommand()  )  {    return command;  }}// _______________________// Parse macro definitions./** * Tries to identify a macro definition, that is a * \def or \newcommand (\renewcommand). */protected MacroDefinition MacroDefinition() :{  MacroDefinition definition;}{  (    definition = DefCommand()  | definition = NewCommandCommand()  )  {    return definition;  }}// ____________________// Parse \def commands./** * Tries to identify a \def command. Will find all command of the syntax * \def\foobar#1#2#3{xxx} */protected MacroDefinition DefCommand() :{  MacroDefinition definition;  Token identifier;  Command macroCommand;  Group macroGroup;}{  // Find the identifier ("\def").  identifier = < DEF_COMMAND_PREFIX >  {    definition = new MacroDefinition(identifier.image, identifier);  }  // Allow any whitespaces.  (<WHITESPACE> | <NEW_LINE>)*  (    // The macro may be given as a command ...      macroCommand = MacroCommand()    // Create command name: \def\foobar    { definition.setKey(new Group(macroCommand)); }    |    (      <GROUP_START>            // The macro may be given as a command ...        macroCommand = MacroCommand()      { definition.addValue(new Group(macroCommand)); }      <GROUP_END>    )  )  // Find the markers #1#2... (may be separated by whitespaces).  (LOOKAHEAD(< WHITESPACE >) < WHITESPACE >)*  (    Marker()    (LOOKAHEAD(< WHITESPACE >) < WHITESPACE >)*  )*    // Find the group of the macro (including the arguments).  macroGroup = Group()  { definition.addValue(macroGroup); }  { return definition; }}// ___________________________// Parse \newcommand commands.protected MacroDefinition NewCommandCommand() :{  MacroDefinition definition;  Token identifier;  Command macroCommand;  Group macroGroup;  Group macro2ndGroup;}{  identifier = < NEW_COMMAND_PREFIX >  {    definition = new MacroDefinition(identifier.image, identifier);  }  // Allow any whitespaces.  (<WHITESPACE> | <NEW_LINE>)*  // Find the name of the command to define, which may be wrapped in a group.  (    // The macro may be given as a command ...      macroCommand = MacroCommand()    { definition.setKey(new Group(macroCommand)); }    |     // ... or a group.    macroGroup = Group()    { definition.setKey(macroGroup); }  )  (    LOOKAHEAD(< WHITESPACE >) < WHITESPACE >    |    LOOKAHEAD(< NEW_LINE >) < NEW_LINE >  )*  (    Option()    (      LOOKAHEAD(< WHITESPACE >) < WHITESPACE >      |      LOOKAHEAD(< NEW_LINE >) < NEW_LINE >    )*  )*          // Find the second group, including the arguments of the macro.  macro2ndGroup = Group()  { definition.addValue(macro2ndGroup); }  { return definition; }}/** * Tries to parse a macro command which is defined via a \def command. */protected Command MacroCommand() :{  Token commandName;}{  // Find the command name.  commandName = MacroCommandName()  {    return new Command(commandName.image, commandName);  }}protected Token MacroCommandName() :{  StringBuilder commandName = new StringBuilder();  Token identifier;  Token symbol;  int beginLine = -1;  int endLine = -1;  int beginColumn = -1;  int endColumn = -1;}{  // Find the identifier (usually just "\")  identifier = MacroCommandIdentifier()  {    commandName.append(identifier.image);    beginLine = identifier.beginLine;    endLine = identifier.endLine;    beginColumn = identifier.beginColumn;    endColumn = identifier.endColumn;  }  // Find the symbols of the command name.  (    symbol = MacroCommandSymbol()    {      commandName.append(symbol.image);      endLine = symbol.endLine;      endColumn = symbol.endColumn;    }  )*  {    Token token = new Token(-2, commandName.toString());    token.beginLine = beginLine;    token.endLine = endLine;    token.beginColumn = beginColumn;    token.endColumn = endColumn;    return token;  }}protected Token MacroCommandIdentifier() :{  Token identifier;}{  (    identifier = UsualCommandIdentifier()  | identifier = WellDefinedCommandName()  )  {    return identifier;  }}/** * Tries to parse a symbol of the name of a command, which is defined via a * \def command. */protected Token MacroCommandSymbol() :{  Token symbol;}{  (    symbol = < CHAR >  | symbol = < DIGIT >  | symbol = < OTHER_SYMBOL >  )  {    return symbol;  }}// _________________________________________________________// Parse commands which were defined via a macro definition.protected Command MacroDefinedCommand() :{  Command command;  Token commandName;  Group group;}{  commandName = MacroDefinedCommandName()  {    command = new Command(commandName.image, commandName);  }  [    LOOKAHEAD(Option())    Option()  ]  (    LOOKAHEAD(Group())    group = Group()    {      command.addArgument(group);    }  )*  { return command; }}protected Token MacroDefinedCommandName() :{  StringBuilder commandName = new StringBuilder();  Token identifier;  Token symbol;  int beginLine = -1;  int endLine = -1;  int beginColumn = -1;  int endColumn = -1;}{  LOOKAHEAD({ belongsToMacroDefinedCommandName() })  identifier = MacroCommandIdentifier()  {    log("CONSUME IDENTIFIER: " + identifier);    commandName.append(identifier.image);    beginLine = identifier.beginLine;    endLine = identifier.endLine;    beginColumn = identifier.beginColumn;    endColumn = identifier.endColumn;  }//  LOOKAHEAD({ belongsToMacroDefinedCommandName() })//  symbol = MacroCommandSymbol()//  {//    log("CONSUME SYMBOL: " + symbol);//    commandName.append(symbol.image);//  }  (    LOOKAHEAD({ belongsToMacroDefinedCommandName() })    symbol = MacroCommandSymbol()    {      log("CONSUME TOKEN: " + symbol);      commandName.append(symbol.image);      endLine = identifier.endLine;      endColumn = identifier.endColumn;    }  )*  {    Token token = new Token(- 2, commandName.toString());    token.beginLine = beginLine;    token.endLine = endLine;    token.beginColumn = beginColumn;    token.endColumn = endColumn;    return token;  }}// _____________________// Parse usual commands.protected Command UsualCommand() :{  Command command;  Token commandName;  Group group;  Option option;}{  commandName = UsualCommandName()  {    command = new Command(commandName.image, commandName);  }  [    LOOKAHEAD((< WHITESPACE >)* Option())    (< WHITESPACE >)*    option = Option()    {      command.addArgument(option);    }  ]  (    LOOKAHEAD((< WHITESPACE >)* Group())    (< WHITESPACE >)*    group = Group()    {      command.addArgument(group);    }  )*  [    LOOKAHEAD(Option())    option = Option()    {      command.addArgument(option);    }  ]  {    return command;  }}protected Token UsualCommandName() :{  StringBuilder commandName = new StringBuilder();  Token identifier;  Token symbol;  int beginLine = -1;  int endLine = -1;  int beginColumn = -1;  int endColumn = -1;}{  identifier = UsualCommandIdentifier()  {    commandName.append(identifier.image);    beginLine = identifier.beginLine;    endLine = identifier.endLine;    beginColumn = identifier.beginColumn;    endColumn = identifier.endColumn;  }  (    LOOKAHEAD(UsualCommandSymbol())    symbol = UsualCommandSymbol()    {      commandName.append(symbol.image);      endLine = symbol.endLine;      endColumn = symbol.endColumn;    }  )*  // The command name is may be followed by a "*" (\section*)  [   LOOKAHEAD(<STAR>) symbol = < STAR >   {     commandName.append(symbol.image);     endLine = symbol.endLine;     endColumn = symbol.endColumn;   }  ]    {    Token token = new Token(- 2, commandName.toString());    token.beginLine = beginLine;    token.endLine = endLine;    token.beginColumn = beginColumn;    token.endColumn = endColumn;    return token;  }}protected Token UsualCommandIdentifier() :{  Token token;}{  (    token = < COMMAND_PREFIX >  | token = < DEF_COMMAND_PREFIX >  | token = TeXCommandWithCharArgAndOptionalWhitespaceName()  | token = TeXCommandWithCharArgAndMandatoryWhitespaceName()  | token = TeXCommandWithSingleWordArgAndMandatoryWhitespaceName()  | token = TeXCommandWithSingleWordArgAndOptionalWhitespaceName()//  | token = TeXCommandWithMultipleWordsArgAndOptionalWhitespaceName()  )  { return token; }}protected Token UsualCommandSymbol() :{  Token token;}{  (    token = < CHAR >  | token = < DIGIT >  | token = < AT > // allow commands like \@ifnextchar  )  {    return token;  }}// ____________________________// Parse well defined commands./** * Tries to identify a well defined command, that is a command with a well-known * syntax and that are not a prefix of another command. Examples are: \\, \%, * \{, etc. */protected Command WellDefinedCommand() :{  Token commandName;}{  commandName = WellDefinedCommandName()  [LOOKAHEAD(Option()) Option()] // Allow commands like \\[10mm]  {    return new Command(commandName.image, commandName);  }}/** * Tries to parse the name of a well defined command. */protected Token WellDefinedCommandName() :{  Token token;}{  (    token = < WELL_DEFINED_DEFAULT_COMMAND >  | token = < WELL_DEFINED_TABBING_COMMAND >  | token = < WELL_DEFINED_COMMON_COMMAND >  | token = < BEGIN_TABBING >  | token = < END_TABBING >  )  {    return token;  }}// ______________________// Parse escape commands./** * Finds commands with a single char as argument like * \"a, \" a, \"{a}, \" {a} or \"\i where the whitespace between command-name * and the argument is optional.  */protected Command TeXCommandWithCharArgAndOptionalWhitespace() :{  Token commandName;  Command command;  Group group;  Token symbol;  Token arg;}{  commandName = TeXCommandWithCharArgAndOptionalWhitespaceName()  {    command = new Command(commandName.image, commandName);  }  // Whitespaces are optional.  (< WHITESPACE > | < NEW_LINE >)*  (    // It may follow a single char, a group or a command like \i.    // Find a single char.    (      symbol = < CHAR >      | symbol = < DIGIT >    )    { group = new Group(new Text(symbol.image, symbol)); }    |    // Find a command like \i.    arg = UsualCommandName()    { group = new Group(new Command(arg.image, arg)); }    |    // Find a group.    group = Group()  )  { command.addArgument(group); }  { return command; }}/** * Parses the name of a 'TeXCommandWithCharArgAndOptionalWhitespace'. */protected Token TeXCommandWithCharArgAndOptionalWhitespaceName() :{  Token token;}{  (    token = < COMMAND_WITH_CHAR_ARG_OPTIONAL_WHITESPACE_DEFAULT >  | token = < COMMAND_WITH_CHAR_ARG_OPTIONAL_WHITESPACE_COMMON >  | token = < COMMAND_WITH_CHAR_ARG_OPTIONAL_WHITESPACE_TABBING >  )  {    return token;  }}/** * Finds commands with a single char as argument like * \acute a or \acute{a} where the whitespace between command-name * and the argument is mandatory (\acutea is *not* allowed).  */protected Command TeXCommandWithCharArgAndMandatoryWhitespace() :{  Token commandName;  Command command;  Group group;  Token symbol;  Token arg;}{  commandName = TeXCommandWithCharArgAndMandatoryWhitespaceName()  { command = new Command(commandName.image, commandName); }  (    (      // Whitespace is mandatory.      (< WHITESPACE > | < NEW_LINE >)+      (        // It may follow a single char, a command like \i or a group.        (symbol = < CHAR > | symbol = < DIGIT >)        { group = new Group(new Text(symbol.image, symbol)); }        |        // Allow the command \'\i.        arg = UsualCommandName()        { group = new Group(new Command(arg.image, arg)); }        |         group = Group()      )    )    |        // Groups and commands are allowed to follow without whitespace.    (      group = Group()      |      // Allow the command \'\i.      arg = UsualCommandName()      { group = new Group(new Command(arg.image, arg)); }    )  )  { command.addArgument(group); }  { return command; }}/** * Parses the name of a 'TeXCommandWithCharArgAndMandatoryWhitespace'. */protected Token TeXCommandWithCharArgAndMandatoryWhitespaceName() :{  Token token;}{  (    token = < COMMAND_WITH_CHAR_ARG_MANDATORY_WHITESPACE >  )  {    return token;  }}/** * Finds commands with multiple chars as argument like * \vskip5pt or \vskip 5pt where the whitespace between command-name * and the argument is optional.  */protected Command TeXCommandWithSingleWordArgAndOptionalWhitespace() :{  Token commandName;  Command command;  Text argText;  Group argGroup;  Command argCommand;}{  commandName = TeXCommandWithSingleWordArgAndOptionalWhitespaceName()  {    command = new Command(commandName.image, commandName);  }  (< WHITESPACE > | < NEW_LINE >)*  (    argGroup = Group()    { command.addArgument(argGroup); }    |    (      (        argCommand = Command()        { command.addArgument(argCommand); }      )? // Optional command to allow commands like "\font\tenrm=cmr10"]      argText = Text()      { command.addArgument(argText); }    )  )   {    return command;  }}/** * Parses the name of a 'TeXCommandWithSingleWordArgAndOptionalWhitespace'. */protected Token TeXCommandWithSingleWordArgAndOptionalWhitespaceName() :{  Token token;}{  (    token = < COMMAND_WITH_WORD_ARG_OPTIONAL_WHITESPACE >  )  {    return token;  }}/** * Finds commands with multiple chars as argument like * "\input foobar.tex" where the whitespace between command-name * and the argument is mandatory (\inputfoobar.tex is *not* allowed).  */protected Command TeXCommandWithSingleWordArgAndMandatoryWhitespace() :{  Token commandName;  Command command;  Text argText;  Group argGroup;  Command argCommand;}{  commandName = TeXCommandWithSingleWordArgAndMandatoryWhitespaceName()  {    command = new Command(commandName.image, commandName);  }  (    // A group is allowed to follow without whitespace.    argGroup = Group()    { command.addArgument(argGroup); }    |    (      (< WHITESPACE > | < NEW_LINE >)+      (        (          (            argCommand = Command()            { command.addArgument(argCommand); }          )? // Optional command to allow commands like "\font\tenrm=cmr10"]          argText = Text()          { command.addArgument(argText); }        )        |        argGroup = Group()        { command.addArgument(argGroup); }      )    )  )   {    return command;  }}/** * Parses the name of a 'TeXCommandWithSingleWordArgAndMandatoryWhitespace'. */protected Token TeXCommandWithSingleWordArgAndMandatoryWhitespaceName() :{  Token token;}{  (    token = < COMMAND_WITH_WORD_ARG_MANDATORY_WHITESPACE >  )  {    return token;  }}// _____________________________________________________________________________// Parse text./** * Finds a text passage. */protected Text Text() :{  StringBuilder text = new StringBuilder();  Token symbol;  int beginLine = 0;  int endLine = 0;  int beginColumn = 0;  int endColumn = 0;  boolean isFirst = true;}{  (    LOOKAHEAD(TextSymbol())    symbol = TextSymbol()    {      text.append(symbol.image);      if (isFirst) {        beginLine = symbol.beginLine;        beginColumn = symbol.beginColumn;      }      endLine = symbol.endLine;      endColumn = symbol.endColumn;      isFirst = false;    }  )+  {    return new Text(text.toString(), beginLine, endLine, beginColumn, endColumn);  }}protected Token TextSymbol() :{  Token token;}{  (    token = < CHAR >  | token = < DIGIT >  | token = < STAR >  | token = < OTHER_SYMBOL >  | token = < AT >//  | token = < UNDERSCORE >//  | token = < CIRCUMFLEX >  )  {    return token;  }}// _____________________________________________________________________________// Parse a group.protected Element PotentialGroup() :{  Group group;  Token token;}{  LOOKAHEAD(Group())  group = Group()  {    return group;  }|   token = < GROUP_START >  {    return new Text(token.image, token);  }}protected Group Group() :{  Group group = new Group();  Token optionEnd;}{  < GROUP_START >  (    LOOKAHEAD(Element(group))    Element(group)  | optionEnd = < OPTION_END >    {      group.addElement(new Text(optionEnd.image, optionEnd));    }  )*  < GROUP_END >  {    return group;  }}// _____________________________________________________________________________// Parse an option.protected Element PotentialOption() :{  Option option;  Token token;}{  LOOKAHEAD(Option())  option = Option()  {    return option;  }|   token = < OPTION_START >  {    return new Text(token.image, token);  }}protected Option Option() :{  Option option = new Option();  Token groupEnd;}{  < OPTION_START >  (    LOOKAHEAD(Element(option))    Element(option)  | groupEnd = < GROUP_END >    {      option.addElement(new Text(groupEnd.image, groupEnd));    }  )*  < OPTION_END >  {    return option;  }}// _____________________________________________________________________________/** * Finds a marker within a command, that is a placeholder like #1 in a macro. */protected Marker Marker() :{  Token token;}{  token = < MARKER >  {    return new Marker(Integer.parseInt(token.image.substring(1)), token);  }}/** * Finds new paragraphs. */protected NewParagraph NewParagraph() :{  Token token;}{  (    token = < NEW_PARAGRAPH >  )  {    return new NewParagraph(token);  }}/** * Finds newlines. */protected NewLine Newline() :{  Token token;}{  (    token = < NEW_LINE >  )  {    return new NewLine(token);  }}/** * Finds whitespaces. */protected Whitespace Whitespace() :{  Token token;}{  (    LOOKAHEAD(< WHITESPACE >) token = < WHITESPACE >   )+  {    return new Whitespace(token);  }}// =============================================================================// Define the tokens.TOKEN_MGR_DECLS :{  Stack < Integer > stateHistory = new Stack < Integer > ();}// _____________// Skip comments.< DEFAULT, IN_TABBING > SKIP :{  < "%" >  {    stateHistory.push(IN_COMMENT);  }  : IN_COMMENT}< IN_COMMENT > SPECIAL_TOKEN:{  // Switch back to the previous state on a new line.  <COMMENT_NEW_LINE: <NEW_LINE>>  {    stateHistory.pop();    SwitchTo(stateHistory.isEmpty() ? DEFAULT : stateHistory.peek());  }}< IN_COMMENT > SKIP :{  < ~[ ] >}// ____________________// Tabbing environment./** * There are commands, which have different meanings in tabbing * environments. Handle these commands separately. */< DEFAULT, IN_COMMENT >TOKEN :{  // Switch into IN_TABBING state on "\begin{tabbing}"  < BEGIN_TABBING : < COMMAND_PREFIX > "begin" (< WHITESPACE >)* < GROUP_START > "tabbing" < GROUP_END >>  {    stateHistory.push(IN_TABBING);  }  : IN_TABBING}< IN_TABBING >TOKEN :{  // Switch back to the previous state on "\end{tabbing}"  < END_TABBING : < COMMAND_PREFIX > "end" (< WHITESPACE >)* < GROUP_START > "tabbing" < GROUP_END >>  {    stateHistory.pop();    SwitchTo(stateHistory.isEmpty() ? DEFAULT : stateHistory.peek());  }}// ______________________________// Define a valid text character.< DEFAULT, IN_TABBING >TOKEN :{    <WHITESPACE:    (" " | "\t" | "\f") >  | <NEW_LINE:      ("\r\n" | "\n" | "\r") >//  | <NEW_PARAGRAPH: (<NEW_LINE> (<WHITESPACE>)* <NEW_LINE> ((<WHITESPACE>)* <NEW_LINE>)*)>  | <NEW_PARAGRAPH: (<NEW_LINE> (<WHITESPACE>)* <NEW_LINE>)>}< DEFAULT, IN_TABBING >TOKEN :{    <STAR:       "*">  | <UNDERSCORE: "_">  | <CIRCUMFLEX: "^">}// _____________________________________________// Define the valid group starts and group ends.< DEFAULT, IN_TABBING >TOKEN :{  < GROUP_START : "{" >| < GROUP_END : "}" >}// _______________________________________________// Define the valid option starts and option ends.< DEFAULT, IN_TABBING >TOKEN :{  < OPTION_START : "[" >| < OPTION_END : "]" >}// _________________________________// Define the common command prefix.< DEFAULT, IN_TABBING >TOKEN :{  < COMMAND_PREFIX : "\\" >}< DEFAULT, IN_TABBING >TOKEN :{  < DEF_COMMAND_PREFIX : ("\\def") >}< DEFAULT, IN_TABBING >TOKEN :{  < NEW_COMMAND_PREFIX : ( "\\newcommand" | "\\renewcommand") >}// _____________________________// Define well-defined commands.< DEFAULT >TOKEN :{  < WELL_DEFINED_DEFAULT_COMMAND :    (      "\\-" // optional hyphenation.    | "\\<"    | "\\>"    ) >}< IN_TABBING >TOKEN :{  < WELL_DEFINED_TABBING_COMMAND :    (      "\\=" // in tabbing environment sets a tab stop.    | "\\'" // in tabbing environment moves current column to the right of the previous column.    | "\\`" // in tabbing environment moves all text which follows (up to \\) to the right margin.    | "\\<" // in tabbing environment puts text to left of local left margin    | "\\>" // in tabbing environment is a forward tab. Otherwise, medium space    | "\\+" // in tabbing environment moves the left margin of the next and all the following commands one tab stop to the right.    | "\\-" // in tabbing environment moves left margin to the left by one tab stop.    | "\\kill" // in tabbing environment allows you to set tab stops without producing text    ) >}< DEFAULT, IN_TABBING >TOKEN :{  < WELL_DEFINED_COMMON_COMMAND :    (      "\\ " // ordinary space after period    | "\\" < NEW_LINE > //     | "\\!" // negative thin space    | "\\#" // prints a pound sign: #.    | "\\$" // prints a dollar sign: $.    | "\\%" // prints a percent sign: %.    | "\\&" // prints an ampersand: &.    | "\\(" // start math mode. Same as \begin{math} or $.    | "\\)" // end math mode. Same as \end{math} or $    | "\\*" // is a discretionary multiplication sign, at which a line break is allowed    | "\\+" // moves left margin to the right by one tab stop. Begin tabbed line    | "\\," // thin space    | "\\/" // inserts italics adjustment space    | "\\:" // medium space    | "\\;" // thick space    // | "\\@" // declares the period that follows is to be a sentence-ending period // DISABLED because "@" is now a valid command name symbol.    | "\\[" // same as \begin{displaymath} or $$.    | "\\]" // same as \end{displaymath} or $$.    | "\\\\" // terminates a line    | "\\\\*" // terminates a line, but disallows a pagebreak.    | "\\_" // is an underscore, as in hours worked.    | "\\{" // prints a curly left brace: {.    | "\\}" // prints a curly right brace: }.    | "\\|" // is || (math mode).    | "$" // begins or ends math mode.    | "$$" // begins or ends math mode.    | "\\-" // optional hyphenation.    | "\\noindent"    | "\\big("    | "\\Big("    | "\\bigg("    | "\\Bigg("    | "\\big)"    | "\\Big)"    | "\\bigg)"    | "\\Bigg)"    | "\\big["    | "\\Big["    | "\\bigg["    | "\\Bigg["    | "\\big]"    | "\\Big]"    | "\\bigg]"    | "\\Bigg]"    | "\\big\\{"    | "\\Big\\{"    | "\\bigg\\{"    | "\\Bigg\\{"    | "\\big\\}"    | "\\Big\\}"    | "\\bigg\\}"    | "\\Bigg\\}"    | "\\big{[}"    | "\\big{]}"    | "\\big{(}"    | "\\big{)}"    | "\\bigg{[}"    | "\\bigg{]}"    | "\\bigg{(}"    | "\\bigg{)}"    | "\\Big{[}"    | "\\Big{]}"    | "\\Big{(}"    | "\\Big{)}"    | "\\Bigg{[}"    | "\\Bigg{]}"    | "\\Bigg{(}"    | "\\Bigg{)}"    ) >}// _______________________// Define escape commands.< DEFAULT >TOKEN :{  < COMMAND_WITH_CHAR_ARG_OPTIONAL_WHITESPACE_DEFAULT :    (      "\\=" // makes a macron accent    | "\\-" // per default, optional hyphenation.    | "\\'" // per default, makes an acute accent, as ó.    | "\\`" // per default, makes a grave accent, as `o.    ) >}< IN_TABBING >TOKEN :{  < COMMAND_WITH_CHAR_ARG_OPTIONAL_WHITESPACE_TABBING :    (      "\\a´" // makes an acute accent in tabbing environment, as ó    | "\\a`" // makes a grave accent in tabbing environment, as ò    | "\\a=" // makes a macron accent in tabbing environment    ) >}< DEFAULT, IN_TABBING >TOKEN :{  < COMMAND_WITH_CHAR_ARG_OPTIONAL_WHITESPACE_COMMON :    (      "\\\"" // makes an umlaut, as ö.    | "\\^" // makes a circumflex, as â    | "\\~" // makes a tilde over a letter    | "\\." // puts a dot accent over a letter,    ) >}< DEFAULT, IN_TABBING >TOKEN :{  < COMMAND_WITH_CHAR_ARG_MANDATORY_WHITESPACE :    (      "\\acute"    | "\\grave"    | "\\hat"    | "\\widehat"    | "\\check"    | "\\tilde"    | "\\widetilde"    | "\\bar"    | "\\overbar"    | "\\ocirc"    | "\\cal"    | "\\mathcal"    | "\\dot"    | "\\breve"    | "\\vec"    ) >}< DEFAULT >TOKEN :{  < COMMAND_WITH_WORD_ARG_OPTIONAL_WHITESPACE :    (      "\\vskip"    | "\\hskip"    | "\\topsep"    | "\\parsep"    | "\\partopsep"    | "\\itemsep"    | "\\leftmargin"    | "\\rightmargin"    | "\\topmargin"    | "\\bottommargin"    | "\\listparindent"    | "\\itemindent"    | "\\labelwidth"    | "\\labelsep"    | "\\parindent"    | "\\baselineskip"    | "\\textwidth"    | "\\textheight"    | "\\oddsidemargin"    | "\\evensidemargin"    | "\\headsep"    | "\\voffset"    | "\\hoffset"    // Identify commands like \catcode`\@=11 (cond-mat0001253).    | "\\catcode`"    // Identify commands like \font\tenrm=cmr10 (cond-mat0001253).    // "\font" is the command name and "\tenrm" the optinal command which is    // allowed in the grammar specification.    | "\\vrule"    | "\\font"    | "\\leftskip"    | "\\rightskip"    | "\\parskip"    )  >}< DEFAULT >TOKEN :{  < COMMAND_WITH_WORD_ARG_MANDATORY_WHITESPACE :    (      "\\input"      // Disabled because "{\large \bf Figures}" was resolved to {\large \bf{Figures}}      // and hence was not found in element references."//    | "\\bf" //    | "\\it"//      | "\\tiny"//      | "\\scriptsize"//      | "\\footnotesize"//      | "\\small"//      | "\\normalsize"//      | "\\large"//      | "\\Large"//      | "\\LARGE"//      | "\\huge"//      | "\\Huge"    )  >}//< DEFAULT >//TOKEN ://{//  < COMMAND_WITH_MULTI_ELEMENTS_ARG_MANDATORY_WHITESPACE ://    (//      "\\tiny"//      | "\\scriptsize"//      | "\\footnotesize"//      | "\\small"//      | "\\normalsize"//      | "\\large"//      | "\\Large"//      | "\\LARGE"//      | "\\huge"//      | "\\Huge"//    )//  >//}// ______________// Define Marker.< DEFAULT, IN_TABBING >TOKEN :{  < MARKER : "#" < DIGIT >>}// ______________< DEFAULT, IN_TABBING >TOKEN : {    < #UPPERCASE_CHAR : ([ "A"-"Z" ] | "\u00d6" | "\u00c4" | "\u00dc" ) >  | < #LOWERCASE_CHAR : ([ "a"-"z" ] | "\u00f6" | "\u00e4" | "\u00fc" | "\u00df" ) >  | < DIGIT : [ "0"-"9" ] >  | < CHAR : (< UPPERCASE_CHAR > | < LOWERCASE_CHAR >) >}< DEFAULT, IN_TABBING >TOKEN :{  < AT : "@" >}< DEFAULT, IN_TABBING >TOKEN :{  < OTHER_SYMBOL : ~[ ] >}